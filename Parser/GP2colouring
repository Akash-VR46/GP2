/* macro definitions */

Colouring = ((colour; if illegal! then stop)!; back)!

/* rule definitions */

init(x:atom)
[
 (1,1) |
 ( n1(R), x, (1,1) ) |
]

=>

[
 (1,1) |
 ( n1(R), x:0, (1,1) ) |
]

interface { (n1, n1) }
injective = true

stop(x:list)
[
 (1,1) |
 ( n1(R), x, (1,1) ) |
]

=>

[
 (1,1) |
 ( n1(R), x:0 #grey, (1,1) ) |
]

interface { (n1, n1) }
injective = true

unmarked(x:list)
[
 (1,1) |
 ( n1(R), x, (1,1) ) |
]

=>

[
 (1,1) |
 ( n1(R), x, (1,1) ) |
]

interface { (n1, n1) }
injective = true

/* colouring rules */

colour1(a:list; i:int; x,y:atom)
[
 (1,1) |
 ( n1(R), x:i, (1,1) ), ( n2, y, (1,1) ) |
 ( e1, n1, n2, a)
]

=>

[
 (1,1) |
 ( n1, x:i, (1,1) ), ( n2(R), y:1-i, (1,1) ) |
 ( e1, n1, n2, a #dashed)
]

interface { (n1, n1), (n2, n2) }
injective = true

colour2(a:list; i:int; x,y:atom)
[
 (1,1) |
 ( n1(R), x:i, (1,1) ), ( n2, y, (1,1) ) |
 ( e1, n2, n1, a)
]

=>

[
 (1,1) |
 ( n1, x:i, (1,1) ), ( n2(R), y:1-i, (1,1) ) |
 ( e1, n2, n1, a #dashed)
]

interface { (n1, n1), (n2, n2) }
injective = true

/* checking if a node adjacent to the root has the same colour as the root */

illegal1(a:list; i:int; x,y:atom)
[
 (1,1) |
 ( n1(R), x:i, (1,1) ), ( n2, y:i, (1,1) ) |
 ( e1, n1, n2, a)
]

=>

[
 (1,1) |
 ( n1(R), x:i, (1,1) ), ( n2, y:i, (1,1) ) |
 ( e1, n1, n2, a)
]

interface { (n1, n1), (n2, n2) }
injective = true

illegal2(a:list; i:int; x,y:atom)
[
 (1,1) |
 ( n1(R), x:i, (1,1) ), ( n2, y:i, (1,1) ) |
 ( e1, n2, n1, a)
]

=>

[
 (1,1) |
 ( n1(R), x:i, (1,1) ), ( n2, y:i, (1,1) ) |
 ( e1, n2, n1, a)
]

interface { (n1, n1), (n2, n2) }
injective = true

/* backtracks along a path of dashed edges */

back1(a:list; i:int; x,y:atom)
[
 (1,1) |
 ( n1(R), x:i, (1,1) ), ( n2, y:j, (1,1) ) |
 ( e1, n1, n2, a #dashed)
]

=>

[
 (1,1) |
 ( n1, x:i, (1,1) ), ( n2(R), y:j, (1,1) ) |
 ( e1, n1, n2, a)
]

interface { (n1, n1), (n2, n2) }
injective = true

back2(a:list; i:int; x,y:atom)
[
 (1,1) |
 ( n1(R), x:i, (1,1) ), ( n2, y:j, (1,1) ) |
 ( e1, n2, n1, a #dashed)
]

=>

[
 (1,1) |
 ( n1, x:i, (1,1) ), ( n2(R), y:j, (1,1) ) |
 ( e1, n2, n1, a)
]

interface { (n1, n1), (n2, n2) }
where edge(n1, n2, "a" )
injective = true

/* GP program text */

main = try (init; Colouring; unmarked)

