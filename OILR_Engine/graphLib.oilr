9  constant: '\t'
10 constant: '\n'
27 constant: '\e'

: #   [ '\n' = ] scan-in  ;   #immediate
# and now we have comments. Yay!

# allow aliasing of existing words without adding a
# layer of indirection
: alias:  #immediate  # ( xt -- )  ( -- )
	create-immed  ,    # store the word being aliased
	does        @ ,  # when called compile the aliased word
;

# make address manipulation more readable...
' cell alias: cells
' -    alias: before
' +    alias: after

: next-cell  here   1 cell after   ;
: prev-cell  here   1 cell before  ;

# now let's implement conditionals
: compile-jump     ,    here    0 ,  ;        #  xt -- addr
: compile-conditional-jump   ' zbranch  compile-jump ;
: compile-unconditional-jump ' branch   compile-jump ;
: jump-target   dup   here swap -   swap !  ;

variable: if-depth
: if     #immediate   compile-conditional-jump   if-depth inc-var  ;
: else   #immediate   compile-unconditional-jump   push   jump-target   pop ;
: endif  #immediate   jump-target   if-depth dec-var ;


# Imperative looping
: times      #immediate   # n --
	' push ,					# push i
	here   ' peek ,				# this is where we jump back to
	compile-conditional-jump    # jump out of loop if i==0
	' pop , ' 1- , ' push ,     # decrement the counter
	swap                        # leave NoS:exit-jump ToS:start-of-loop
;
: forever    #immediate
	-1 compile-literal
	' push ,   here   ' peek ,
	compile-conditional-jump
	swap
;
: repeat     #immediate    # exit-jump start-of-loop  -- 
	next-cell -    compile-unconditional-jump   !
	jump-target
	' trash ,
;

# exceptions are basically just variables
: exception:   #immediate    create-variable  ;


# buffered output

1000 cells buffer constant: OutputBufferStart
variable: output-buffer
OutputBufferStart output-buffer !
: %s  # s -- 
	# copy a string into the output buffer
	dup @ push # length
	1 cell after   peek   output-buffer @   copy-bytes
	pop   output-buffer @   +   output-buffer !
;
: %c  # c -- 
	# copy a char into the output buffer
	output-buffer @ !b
	output-buffer inc-var
;
: _c 
	dup if
		%c tail: _c
	endif
	drop
;
: %d  # n -- 
	# copy an int into the output buffer
	dup 0 < if
		neg
		'-' %c
	endif
	10 decompose
	_c
;
: clear-output   OutputBufferStart output-buffer !   ;
: flush-output
	0   output-buffer @   ! # guarantee null-termination
	OutputBufferStart putz
	clear-output
;


# ################################################################# #

variable: index-size

# NOTE: bytes->elems gives the number of elems that will fit into 
#   bytes of space. There may be space left over. note also the
#   unsigned shift.
: bytes->elems  GraphElemShift u-shift-down ;  # bytes -- n-elems

: elems  GraphElemShift shift-up  ;  # n -- bytes
' elems alias: elem

: next-elem   1 elem after   ;  # elem -- elem+1



: OILR #immediate
	create # n --
		dup index-size !
		2* cells allot
	does  # n -- addr
		2* cells after
;
: host-graph #immediate
	use-dict
	elem-align-dp
	here host !
	here host-free !
	use-anon
;



# Index structure:  |  next  |  count
: .idx-len  1 cell after  ;

# List structure:   |  next  |  head  |  prev
: .idx-next ;  #immediate
: .idx-head  1 cell after  ;
: .idx-prev  2 cells after ;       
: idx->elem  GraphElemMask and  ;  #  list -- elem

# Elem Structure   |  flags  | ...
: .elem-flags  ;  #immediate
: .elem-label 1 cell after ;

: .edge-src 2 cells after ;
: .edge-tgt 3 cells after ;

: ->next .idx-next @ ;
: ->prev .idx-prev @ ;
: ->head .idx-head @ ;

: alloc-elem  #  -- elem
	freelist @ dup  if
		dup @ freelist !
	else
		use-dict
		drop here GraphElemSize allot
		use-anon
	endif 
;
: free-elem   #  elem -- 
	freelist @ over !
	freelist !
;

: available-space   # -- n-elems
	use-dict
	get-brk-addr here -   bytes->elems
	use-anon
;

exception: OutOfMemory
constant: MaxAlloc

: check-space
	available-space 1 <= if
		get-heap-size
		stash 0 < if
			# high bit is already set, we can't double any more,
			# and we're in danger of running into the stack and mmapped area
			OutOfMemory raise
		endif
		pop 1 shift-up set-heap-size  # double the memory
	endif
;

2 constant: TypeBits
1 constant: LabelFlagBits
3 constant: ColourFlagBits
2 constant: OFlagBits
2 constant: IFlagBits
2 constant: LFlagBits
1 constant: RFlagBits

0 constant: FreeType
1 constant: NodeType
2 constant: EdgeType


3 constant: ColourFlagShift

4 	constant: LabelFlagMask
7 ColourFlagShift shift-up
	constant: ColourFlagMask

: index-node   # node -- 
	.elem-flags @  TypeBits shift-down
	drop  # todo
;

: init-node   NodeType over .elem-flags !  ;  # elem -- node
: init-edge  # src tgt elem -- edge
	EdgeType over .elem-flags !
	stash .edge-tgt !
	pop   .edge-src !
;

: is-node?  .elem-flags @   NodeType  and  ;
: is-edge?  .elem-flags @   EdgeType  and  ;

# Graph element creation and deletion
: unsafe-add-node   alloc-elem init-node index-node  ;  # --
: unsafe-add-edge   alloc-elem init-edge drop ; # --

: add-node  check-space unsafe-add-node ;
: edge      check-space unsafe-add-edge ;

: delete-node   free-elem   ;         # node --
: delete-edge   free-elem   ;         # edge --


: nodes   # n -- 
	stash available-space  >=  if
		# if there isn't space, allocate enough...
		peek elems  grow-heap
	endif
	pop times  unsafe-add-node  repeat
;



: get-label-flag   .elem-flags @   LabelFlagMask   and   ;   # elem -- n
: set-label-flag   stash .elem-flags @   LabelFlagMask   or  pop .elem-flags !  ;  # n elem -- 

: label  # label elem -- 
	stash .elem-label !
	pop set-label-flag
;


0 constant: Uncoloured
1 constant: Red
2 constant: Blue
3 constant: Green
4 constant: Grey
7 constant: Dashed

: get-colour  .elem-flags @  ColourFlagMask and   ColourFlagShift shift-down ;
: colour  # colour elem --
	push ColourFlagShift shift-up
	peek .elem-flags @  ColourFlagMask not  and  or # clear the old colour then set the new
	pop !
;

: graph-elem    elems   host @   +    ; # n -- elem
: get-elem-id   host @ -  bytes->elems  ;  # elem -- n
: count-elems   use-dict   here get-elem-id   use-anon  ;

: spc 32 %c ;

exception: TODO

: has-label?    get-label-flag   ;

: _put-label # elem -- 
	dup has-label? if
		.elem-label @ %d
	else
		drop StrEmpty %s
	endif
;
: _put-colour  # elem --
	get-colour ColourTable swap cells after @ %s
;

: put-node   # elem --
	StrLeader %s   'n' %c   dup get-elem-id %d   StrComma %s   dup _put-label  _put-colour  StrTrailer %s
	flush-output
;
: put-edge
	StrLeader %s   'e' %c
		dup get-elem-id %d   StrComma %s
		dup .edge-src @ get-elem-id   'n' %c %d   StrComma %s
		dup .edge-tgt @ get-elem-id   'n' %c %d   StrComma %s
		dup _put-label   _put-colour   StrTrailer %s
	flush-output
;

: dump-graph
	'[' putc '\n' putc
	host @
	count-elems  # number of elems
	stash times   dup is-node? if  dup put-node  endif   next-elem  repeat   drop
	'|' putc '\n' putc
	host @
	pop   times   dup is-edge? if  dup put-edge  endif   next-elem  repeat
	']' putc '\n' putc
;


: bnd  #  dest spc -- bool
	# traverse a single OILR index
	drop drop false
;
: rtz  # bool --
	if return endif  # do nothing true
	trash unframe    # otherwise clear frame and return from calling function
;

: dbn  # reg --
	$$  idx->elem  delete-node
;
: dbe  # reg --
	$$  idx->elem  delete-edge
;


# ################################################################# #


# ################################################################# #


# LabelFlagBits
# 	ColourFlagBits +
# 	OFlagBits +
# 	IFlagBits +
# 	LFlagBits +
# 	RFlagBits + 
1		OILR index

: rule
	frame
#	1 registers
	0  0  bnd   # bind node from spc 0 in reg 0
	rtz

	0 dbn     # delete node bound in reg 0
	unframe
;


: Main
;


# ################################################################# #
# Host graph only! No definitions from here on down...

host-graph

	3 nodes
	0n 1n edge
	1n 0n edge
	1n 2n edge
	2n 0n edge

	42 1n label
	123 6e label

	Red 2n colour

	Dashed 4e colour

# [ count-elems putn nl  get-brk-addr putx nl  anon-code-area-addr @ putx nl  0-exit ] handles OutOfMemory
# forever  add-node  repeat
# -1 times   LabelFlagBits drop  repeat
# -1 times   host @ drop  repeat

Main

dump-graph
available-space putn nl
0-exit ;
