true constant: DEBUG

9  constant: '\t'
10 constant: '\n'
27 constant: '\e'

: MB 20 shift-up ;

: #   [ '\n' = ] scan-in  ;   #immediate
# and now we have comments. Yay!


# allow aliasing of existing words without adding a
# layer of indirection
: alias:  #immediate  # ( xt -- )  ( -- )
	create-immed  ,    # store the word being aliased
	does        @ ,  # when called compile the aliased word
;

# make address manipulation more readable...
' cell alias: cells
' -    alias: before
' +    alias: after

: next-cell  here   1 cell after   ;
: prev-cell  here   1 cell before  ;

# now let's implement conditionals
: compile-jump     ,    here    0 ,  ;        #  xt -- addr
: compile-conditional-jump   ' zbranch  compile-jump ;
: compile-unconditional-jump ' branch   compile-jump ;
: jump-target   dup   here swap -   swap !  ;

variable: if-depth
: if     #immediate   compile-conditional-jump   if-depth inc-var  ;
: else   #immediate   compile-unconditional-jump   push   jump-target   pop ;
: endif  #immediate   jump-target   if-depth dec-var ;


# concatenative-style if
: ifte  # S bool then else -- T
	push push
	if pop trash else trash pop endif
	call
;

: [] [ ] ;
# debugging code is from ? to end of line
DEBUG
	[ [] ]
    [ [ [ '\n' = ] scan-in  ] ]
ifte  as ?  #immediate
# The above also shows how we can use the "as" defining word to do 
# conditional compilation. What this says is "if DEBUG is non-zero
# then define ? to be a no-op immediate word, otherwise define ? to
# be a comment to end-of-line.



# Imperative looping
: times      #immediate   # n --
	' push ,					# push i
	here   ' peek ,				# this is where we jump back to
	compile-conditional-jump    # jump out of loop if i==0
	' pop , ' 1- , ' push ,     # decrement the counter
	swap                        # leave NoS:exit-jump ToS:start-of-loop
;
: forever    #immediate
	-1 compile-literal
	' push ,   here   ' peek ,
	compile-conditional-jump
	swap
;
: repeat     #immediate    # exit-jump start-of-loop  -- 
	next-cell -    compile-unconditional-jump   !
	jump-target
	' trash ,
;

# exceptions are basically just variables
: exception:   #immediate    create-variable  ;


# buffered output

1000 cells buffer constant: OutputBufferStart
variable: output-buffer
OutputBufferStart output-buffer !
: %s  # s -- 
	# copy a string into the output buffer
	dup @ push # length
	1 cell after   peek   output-buffer @   copy-bytes
	pop   output-buffer @   +   output-buffer !
;
: %c  # c -- 
	# copy a char into the output buffer
	output-buffer @ !b
	output-buffer inc-var
;
: _c 
	dup if
		%c tail: _c
	endif
	drop
;
: %d  # n -- 
	# copy an int into the output buffer
	dup 0 < if
		neg
		'-' %c
	endif
	10 decompose
	_c
;
: clear-output   OutputBufferStart output-buffer !   ;
: flush-output
	0   output-buffer @   ! # guarantee null-termination
	OutputBufferStart putz
	clear-output
;


# ################################################################# #

variable: _real-index
variable: index-size
variable: bool-flag

: oilr-index _real-index @ ;

# NOTE: bytes->elems gives the number of elems that will fit into 
#   bytes of space. There may be space left over. note also the
#   unsigned shift.
: bytes->elems  GraphElemShift u-shift-down ;  # bytes -- n-elems

: elems  GraphElemShift shift-up  ;  # n -- bytes
' elems alias: elem

: next-elem   1 elem after   ;  # elem -- elem+1



: OILR #immediate
	create # n --
		here 2 cells before push
		dup index-size !
		2* cells allot
		pop _real-index !
	does  # n -- addr
		2* cells after
;
: host-graph #immediate
	use-dict
	elem-align-dp
	here host !
	here host-free !
	use-anon
;

# backtracking-stack primitives
16 MB constant: BStackSize
BStackSize buffer constant: b-stack-max
b-stack-max BStackSize + constant: b-stack
variable: bsp
b-stack bsp !

# The b-stack is executable. Executing it undoes the changes it documents
# if bool-flag is false or frees preserved resources
: b-return  ip@ bsp !  trash  ;
: b-push  bsp @   1 cell before stash !   pop bsp !  ;
: b-call  DoAddr b-push  bsp @  call ;



# Index structure:  |  next  |  count
: .idx-len  1 cell after  ;

# List structure:   |  next  |  head  |  prev
: .idx-next ;  #immediate
: .idx-head  1 cell after  ;
: .idx-prev  2 cells after ;       
: idx->elem  GraphElemMask and  ;  #  list -- elem

# Elem Structure   |  flags  | ...
: .elem-flags  ;  #immediate
: .elem-label 1 cell after ;

: .edge-src 2 cells after ;
: .edge-tgt 3 cells after ;

: ->next .idx-next @ ;
: ->prev .idx-prev @ ;
: ->head .idx-head @ ;

: alloc-elem  #  -- elem
	freelist @ dup  if
		dup @ freelist !
	else
		use-dict
		drop here GraphElemSize allot
		use-anon
	endif 
;
: free-elem   #  elem -- 
	freelist @ over !
	freelist !
;

: available-space   # -- n-elems
	use-dict
	get-brk-addr here -   bytes->elems
	use-anon
;

exception: OutOfMemory

: check-space
	available-space 1 <= if
		get-heap-size
		stash 0 < if
			# high bit is already set, we can't double any more,
			# and we're in danger of running into the stack and mmapped area
			OutOfMemory raise
		endif
		pop 1 shift-up set-heap-size  # double the memory
	endif
;

2 constant: TypeBits
1 constant: LabelFlagBits
3 constant: ColourFlagBits
2 constant: OFlagBits
2 constant: IFlagBits
2 constant: LFlagBits
1 constant: RFlagBits

0 constant: FreeType
1 constant: NodeType
2 constant: EdgeType


3 constant: ColourFlagShift

4 	constant: LabelFlagMask
7 ColourFlagShift shift-up
	constant: ColourFlagMask

: node-signature   .elem-flags @   TypeBits shift-down   ;  # node -- sig
: index-node   # node -- 
	dup node-signature 
?	dup putn nl
	oilr-index
		stash .idx-next
		pop .idx-len  inc-var
	drop
;
: unindex-node  # node --
	
;

: init-node   NodeType over .elem-flags !  ;  # elem -- node
: init-edge  # src tgt elem -- edge
	EdgeType over .elem-flags !
	stash .edge-tgt !
	pop   .edge-src !
;

: is-node?  .elem-flags @   NodeType  and  ;
: is-edge?  .elem-flags @   EdgeType  and  ;

# Graph element creation and deletion
: unsafe-add-node   alloc-elem init-node index-node  ;  # --
: unsafe-add-edge   alloc-elem init-edge drop ; # --

: add-node  check-space unsafe-add-node ;
: edge      check-space unsafe-add-edge ;

: delete-node   dup unindex-node free-elem   ;         # node --
: delete-edge   free-elem   ;         # edge --


: nodes   # n -- 
	stash available-space  >=  if
		# if there isn't space, allocate enough...
		peek elems  grow-heap
	endif
	pop times  unsafe-add-node  repeat
;


: set-root-flag    stash .elem-flags @   RootFlagMask    or  pop .elem-flags !  ;  # bool elem --

: get-label-flag   .elem-flags @   LabelFlagMask   and   ;   # elem -- n
: set-label-flag   stash .elem-flags @   LabelFlagMask   or  pop .elem-flags !  ;  # n elem -- 

: label  # label elem -- 
	stash .elem-label !
	pop set-label-flag
;


0 constant: Uncoloured
1 constant: Red
2 constant: Blue
3 constant: Green
4 constant: Grey
7 constant: Dashed

: get-colour  .elem-flags @  ColourFlagMask and   ColourFlagShift shift-down ;
: colour  # colour elem --
	push ColourFlagShift shift-up
	peek .elem-flags @  ColourFlagMask not  and  or # clear the old colour then set the new
	pop !
;

: graph-elem    elems   host @   +    ; # n -- elem
: get-elem-id   host @ -  bytes->elems  ;  # elem -- n
: count-elems   use-dict   here get-elem-id   use-anon  ;

# ######   Graph output   ######################################### #

: spc 32 %c ;

exception: TODO

: has-label?    get-label-flag   ;

: _put-label # elem -- 
	dup has-label? if
		.elem-label @ %d
	else
		drop StrEmpty %s
	endif
;
: _put-colour  # elem --
	get-colour ColourTable swap cells after @ %s
;

: put-node   # elem --
	StrLeader %s   'n' %c   dup get-elem-id %d   StrComma %s   dup _put-label  _put-colour  StrTrailer %s
	flush-output
;
: put-edge
	StrLeader %s   'e' %c
		dup get-elem-id %d   StrComma %s
		dup .edge-src @ get-elem-id   'n' %c %d   StrComma %s
		dup .edge-tgt @ get-elem-id   'n' %c %d   StrComma %s
		dup _put-label   _put-colour   StrTrailer %s
	flush-output
;

: dump-graph
	'[' putc '\n' putc
	host @
	count-elems  # number of elems
	stash times   dup is-node? if  dup put-node  endif   next-elem  repeat   drop
	'|' putc '\n' putc
	host @
	pop   times   dup is-edge? if  dup put-edge  endif   next-elem  repeat
	']' putc '\n' putc
;

: maybe   # -- bool
	false  # todo: implementation based on pseudo-random numbers
;

: oilr-true  true  bool-flag ! ;
: oilr-false false bool-flag ! ;

# ######   OILR machine instructions   ############################ #

#      OILR Int          -- Number of OILR indices
#    -- Graph modification
#    | ABN Dst           -- Add and Bind Node to register Dst
#    | ABE Dst Src Tgt   -- Add and Bind Edge to register Dst between nodes in Src & Tgt
#    | DBN Dst           -- Delete Bound Node 
#    | DBE Dst           -- Delete Bound Node
#    
#    | RBN Dst Bool      -- set Root on Bound Node to Bool
#    
#    | CBL Dst Col       -- Colour Bound eLement
#    | LBL Dst Int       -- Label Bound eLement with Int
#
#    -- Graph search
#    | BND Dst Spc          -- Bind next unbound NoDe in Spc to Dst
#    | BED Dst Reg Reg Dir  -- Bind EDge between Regs in Dir
#    | BEN Dst Dst Src Dir  -- Bind Edge and Node by following an edge in Dir from Src
#    | NEC Src Tgt          -- Negative Edge Condition from Src to Tgt
#
#    -- Definitions & program structure
#    | DEF Id               -- DEFine function Id
#    | CAL Id               -- CALl Id, pushing current IP to call-stack
#    | TAR Target           -- jump TARget
#    | BRZ Target           -- BRanch if Zero (i.e. if bool flag is false)
#    | BNZ Target           -- Branch if Non-Zero
#    | BRA Target           -- Branch RAndomly. Take the branch 50% of the time.
#    | BRN Target           -- unconditional BRaNch to Target
#    | RET                  -- RETurn to IP on top of call-stack
#    | RTZ                  -- ReTurn if Zero
#    | RNZ                  -- Return if Non-Zero
#
#    -- Backtracking
#    | BBT                  -- Begin BackTracking section
#    | BAK                  -- unconditionally roll-BAcK backtracking section changes
#    | EBT                  -- End BackTracking secion: commit if flag is true, rollback otherwise
#    -- There is no rollback command. This needs to be done manually with reverse rules.
#
#    -- Stack machine
#    | BLO Dst              -- push Bound eLement Out-degree to stack
#    | BLI Dst              -- push Bound eLement In-degree to stack
#    | BLL Dst              -- push Bound eLement looP-degree to stack
#    | BLR Dst              -- push Bound eLement Rootedness to stack
#    | BLN Dst              -- push Bound eLement's Numeric label to stack
#    | BLC Dst              -- push Bound eLement Colour to stack
#
#    | SHL Int              -- SHift top-of-stack Left by Int bits
#    | OR                   -- bitwise OR top 2 values on the stack
#    | AND                  -- bitwise AND top 2 value on the stack
#
#    -- Misc
#    | NOP                  -- No-OP
#    | TRU                  -- set the boolean register to TRUe
#    | FLS                  -- set the boolean register to FaLSe

: cbl  $$ idx->elem  colour ;   # colour reg
: lbl  $$ idx->elem  label ;    # label  reg
: rbn  $$ idx->elem  set-root-flag ;  # bool reg

: bnd  #  dest spc -- bool
	# traverse a search space
	# TODO: write this
	drop drop false bool-flag !
;
: dbn  # reg --
	$$  idx->elem  delete-node
;
: dbe  # reg --
	$$  idx->elem  delete-edge
;

# Branch instructions
: brn  ' branch ,   ;  #immediate
: brz  ' zbranch ,  ;  #immediate
: bnz  ' not   , ' zbranch , ;  #immediate
: bra  ' maybe , ' zbranch , ;  #immediate

# Return instructions
: ret  trash unframe  ;
: rtz  if return endif      trash unframe   ;
: rnz  if trash unframe endif   ;

# Backtracking
: bbt  ' b-return b-push ; 
: bak  bool-flag @  false bool-flag !  b-call  bool-flag ! ;
: ebt  b-call  ;

# Misc
: nop ;
: tru  true  bool-flag ! ;
: fls  false bool-flag ! ;


# ################################################################# #


# ################################################################# #


# LabelFlagBits
# 	ColourFlagBits +
# 	OFlagBits +
# 	IFlagBits +
# 	LFlagBits +
# 	RFlagBits + 
1		OILR index

: rule
	frame
#	1 registers
	0  0  bnd   # bind node from spc 0 in reg 0
	rtz

	0 dbn     # delete node bound in reg 0
	unframe
;

: Main ;

? exception: CompilationStackUnbalancedAfterProgram
? ds-depth dup if  putn 32 putc CompilationStackUnbalancedAfterProgram raise  endif drop


# ################################################################# #
# Host graph only! No definitions from here on down...

host-graph
	3 nodes
	0n 1n edge
	1n 0n edge
	1n 2n edge
	2n 0n edge

	42 1n label
	123 6e label

	Red 2n colour

	Dashed 4e colour

? exception: CompilationStackUnbalancedAfterHost
? ds-depth dup if  putn 32 putc CompilationStackUnbalancedAfterHost raise  endif drop

# [ count-elems putn nl  get-brk-addr putx nl  anon-code-area-addr @ putx nl  0-exit ] handles OutOfMemory
# forever  add-node  repeat
# -1 times   LabelFlagBits drop  repeat
# -1 times   host @ drop  repeat

Main

dump-graph
available-space putn nl
0-exit
;
