9  constant: '\t'
10 constant: '\n'
27 constant: '\e'

: #   [ '\n' = ] scan-in  ;   #immediate
# and now we have comments. Yay!

# allow aliasing of existing words without adding a
# layer of indirection
: alias:  #immediate  # ( xt -- )  ( -- )
	create-immed  ,    # store the word being aliased
	does        @ ,  # when called compile the aliased word
;

# make address manipulation more readable...
' cell alias: cells
' -    alias: before
' +    alias: after

: next-cell  here   1 cell after   ;
: prev-cell  here   1 cell before  ;

# now let's implement conditionals
: compile-jump     ,    here    0 ,  ;        #  xt -- addr
: compile-conditional-jump   ' zbranch  compile-jump ;
: compile-unconditional-jump ' branch   compile-jump ;
: jump-target   dup   here swap -   swap !  ;

variable: if-depth
: if     #immediate   compile-conditional-jump   if-depth inc-var  ;
: else   #immediate   compile-unconditional-jump   push   jump-target   pop ;
: endif  #immediate   jump-target   if-depth dec-var ;


# Imperative looping
: times      #immediate   # n --
	' push ,					# push i
	here   ' peek ,				# this is where we jump back to
	compile-conditional-jump    # jump out of loop if i==0
	' pop , ' 1- , ' push ,     # decrement the counter
	swap                        # leave NoS:exit-jump ToS:start-of-loop
;
: forever    #immediate
	-1 compile-literal
	' push ,   here   ' peek ,
	compile-conditional-jump
	swap
;
: repeat     #immediate    # exit-jump start-of-loop  -- 
	next-cell -    compile-unconditional-jump   !
	jump-target
	' trash ,
;

# exceptions are basically just variables
: exception:   #immediate    create-variable  ;


# buffered output

1000 cells buffer constant: OutputBufferStart
variable: output-buffer
OutputBufferStart output-buffer !
: %s  # s -- 
	# copy a string into the output buffer
	dup @ push # length
	1 cell after   peek   output-buffer @   copy-bytes
	pop   output-buffer @   +   output-buffer !
;
: %c  # c -- 
	# copy a char into the output buffer
	output-buffer @ !b
	output-buffer inc-var
;
: _c 
	dup if
		%c tail: _c
	endif
	drop
;
: %d  # n -- 
	# copy an int into the output buffer
	dup 0 < if
		neg
		'-' %c
	endif
	10 decompose
	_c
;
: clear-output   OutputBufferStart output-buffer !   ;
: flush-output
	0   output-buffer @   ! # guarantee null-termination
	OutputBufferStart putz
	clear-output
;


# ################################################################# #

variable: index-size

: init-host-graph
	use-dict
	elem-align-dp
	here host !
	here host-free !
	use-anon
;

: OILR #immediate
	create # n --
		dup index-size !
		2* cells allot
		use-dict init-host-graph
	does  # n -- addr
		2* cells after
;

# Index structure:  |  next  |  count
: .idx-len  1 cell after  ;

# List structure:   |  next  |  head  |  prev
: .idx-next ;  #immediate
: .idx-head  1 cell after  ;
: .idx-prev  2 cells after ;       
: .idx-elem  GraphElemMask and  ;  #  list -- elem

# Elem Structure   |  flags  | ...
: .elem-flags  ;  #immediate
: .elem-label 1 cell after ;

: .edge-src 2 cells after ;
: .edge-tgt 3 cells after ;

: ->next .idx-next @ ;
: ->prev .idx-prev @ ;
: ->head .idx-head @ ;

: alloc-elem  #  -- elem
	freelist @ dup  if
		dup @ freelist !
	else
		use-dict
		drop here GraphElemSize allot
		use-anon
	endif 
;
: free-elem   #  elem -- 
	freelist @ over !
	freelist !
;

2 constant: TypeBits

0 constant: FreeType
1 constant: NodeType
2 constant: EdgeType

4 constant: LabelFlagMask

: index-node   # node -- 
	.elem-flags @  TypeBits shift-down
	drop  # todo
;

: init-node   NodeType over .elem-flags !  ;  # elem -- node
: init-edge  # src tgt elem -- edge
	EdgeType over .elem-flags !
	stash .edge-tgt !
	pop   .edge-src !
;

: is-node?  .elem-flags @   NodeType  and  ;
: is-edge?  .elem-flags @   EdgeType  and  ;

# Graph element creation and deletion
: add-node   alloc-elem init-node index-node  ;  # --
: delete-node   free-elem   ;         # --
: nodes  times  add-node  repeat  ;   # n -- 
: edge   alloc-elem init-edge drop  ;  # --


: get-label-flag   .elem-flags @   LabelFlagMask   and   ;   # elem -- n
: set-label-flag   stash .elem-flags @   LabelFlagMask   or  pop .elem-flags !  ;  # n elem -- 

: label  # label elem -- 
	stash .elem-label !
	pop set-label-flag
;


: graph-elem    GraphElemShift shift-up   host @   +    ; # n -- elem
: get-elem-id   host @ -  GraphElemShift shift-down   ;  # elem -- n
: count-elems   use-dict   here get-elem-id   use-anon  ;

: spc 32 %c ;

exception: TODO

: has-label?    get-label-flag   ;

: _put-label # elem -- 
	dup has-label? if
		.elem-label @ %d
	else
		drop StrEmpty %s
	endif
;

: put-node   # elem --
	StrLeader %s   'n' %c   dup get-elem-id %d   StrComma %s   _put-label   StrTrailer %s
	flush-output
;
: put-edge
	StrLeader %s   'e' %c
		dup get-elem-id %d   StrComma %s
		dup .edge-src @ get-elem-id   'n' %c %d   StrComma %s
		dup .edge-tgt @ get-elem-id   'n' %c %d   StrComma %s
		_put-label   StrTrailer %s
	flush-output
;

: dump-graph
	'[' putc '\n' putc
	host @
	count-elems  # number of elems
	stash times   dup is-node? if  dup put-node  endif   GraphElemSize +  repeat   drop
	'|' putc '\n' putc
	host @
	pop   times   dup is-edge? if  dup put-edge  endif   GraphElemSize +  repeat
	']' putc '\n' putc
;


# ################################################################# #

: bits:  #immediate
	create  #  offs bits -- offs'
		over over , , +
	does    #  flags addr -- field
;
	
0 TypeBits bits: type-flag
		 1 bits: b-flag  # laBel
		 3 bits: c-flag  # Colour
		 2 bits: o-flag  # Out degree
		 2 bits: i-flag  # In degree
		 2 bits: l-flag  # Loop degree
		 1 bits: r-flag  # Rootedness
drop ;

1 constant: LabelFlagBits
3 constant: ColourFlagBits
2 constant: OFlagBits
2 constant: IFlagBits
2 constant: LFlagBits
1 constant: RFlagBits

# 10 times  '.' putc  repeat  ;

LabelFlagBits
	ColourFlagBits +
	OFlagBits +
	IFlagBits +
	LFlagBits +
	RFlagBits + 
		OILR index

# No definitions from here on down...

3 nodes
0n 1n edge
0n 1n edge
1n 2n edge
2n 0n edge

42 1n label
123 6e label

dump-graph
0-exit ;
